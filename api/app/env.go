package app

import (
	"fmt"
	"github.com/timeredbull/tsuru/config"
	"github.com/timeredbull/tsuru/fs"
	"github.com/timeredbull/tsuru/log"
	"io/ioutil"
	"launchpad.net/goyaml"
	"os"
	"path"
	"syscall"
	"time"
)

const (
	ChanSize    = 10
	runAttempts = 5
)

type Message struct {
	app     *App
	success chan bool
}

var env chan Message = make(chan Message, ChanSize)

var EnvironConfPath = path.Join(os.ExpandEnv("${HOME}"), ".juju", "environments.yml")

type Cmd struct {
	cmd    string
	result chan CmdResult
	u      Unit
}

type CmdResult struct {
	err    error
	output []byte
}

var cmds chan Cmd = make(chan Cmd)

func init() {
	go collectEnvVars()
	go runCommands()
}

func runCommands() {
	for cmd := range cmds {
		out, err := cmd.u.Command(cmd.cmd)
		if cmd.result != nil {
			r := CmdResult{output: out, err: err}
			cmd.result <- r
		}
	}
}

func runCmd(cmd string, msg Message) {
	c := Cmd{
		u:      *msg.app.unit(),
		cmd:    cmd,
		result: make(chan CmdResult),
	}
	cmds <- c
	var r CmdResult
	r = <-c.result
	for i := 0; r.err != nil && i < runAttempts; i++ {
		cmds <- c
		r = <-c.result
	}
	log.Printf("running %s on %s, output:\n %s", cmd, msg.app.Name, string(r.output))
	if msg.success != nil {
		msg.success <- r.err == nil
	}
}

func collectEnvVars() {
	for e := range env {
		cmd := "cat > /home/application/apprc <<END\n"
		cmd += fmt.Sprintf("# generated by tsuru at %s\n", time.Now().Format(time.RFC822Z))
		for k, v := range e.app.Env {
			cmd += fmt.Sprintf(`export %s="%s"`+"\n", k, v.Value)
		}
		cmd += "END\n"
		runCmd(cmd, e)
	}
}

type JujuEnv struct {
	AccessKey     string `yaml:"access-key"`
	SecretKey     string `yaml:"secret-key"`
	Ec2           string `yaml:"ec2-uri"`
	S3            string `yaml:"s3-uri"`
	JujuOrigin    string `yaml:"juju-origin"`
	Type          string `yaml:"type"`
	AdminSecret   string `yaml:"admin-secret"`
	ControlBucket string `yaml:"control-bucket"`
	Series        string `yaml:"default-series"`
	ImageId       string `yaml:"default-image-id"`
	InstanceType  string `yaml:"default-instance-type"`
}

func newJujuEnv(access, secret string) (JujuEnv, error) {
	ec2, err := config.GetString("juju:ec2")
	if err != nil {
		return JujuEnv{}, err
	}
	s3, err := config.GetString("juju:s3")
	if err != nil {
		return JujuEnv{}, err
	}
	jujuOrigin, err := config.GetString("juju:origin")
	if err != nil {
		return JujuEnv{}, err
	}
	series, err := config.GetString("juju:series")
	if err != nil {
		return JujuEnv{}, err
	}
	imageId, err := config.GetString("juju:image-id")
	if err != nil {
		return JujuEnv{}, err
	}
	instaceType, err := config.GetString("juju:instance-type")
	if err != nil {
		return JujuEnv{}, err
	}
	return JujuEnv{
		Ec2:           ec2,
		S3:            s3,
		JujuOrigin:    jujuOrigin,
		Type:          "ec2",
		AdminSecret:   "",
		ControlBucket: "",
		Series:        series,
		ImageId:       imageId,
		InstanceType:  instaceType,
		AccessKey:     access,
		SecretKey:     secret,
	}, nil
}

func newEnviron(a *App) error {
	envs := map[string]map[string]JujuEnv{}
	file, err := filesystem().OpenFile(EnvironConfPath, syscall.O_CREAT|syscall.O_RDWR, 0600)
	if err != nil {
		return err
	}
	defer file.Close()
	content, err := ioutil.ReadAll(file)
	if err != nil {
		return err
	}
	err = goyaml.Unmarshal(content, &envs)
	if err != nil {
		return err
	}
	if _, ok := envs["environments"]; !ok {
		envs["environments"] = map[string]JujuEnv{}
	}
	jujuEnv, err := newJujuEnv(a.KeystoneEnv.AccessKey, a.KeystoneEnv.secretKey)
	if err != nil {
		return err
	}
	envs["environments"][a.Name] = jujuEnv
	data, err := goyaml.Marshal(&envs)
	_, err = file.Write(data)
	return err
}

var fsystem fs.Fs

func filesystem() fs.Fs {
	if fsystem == nil {
		fsystem = fs.OsFs{}
	}
	return fsystem
}
