// Copyright 2015 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package saml

import (
	"bytes"
	"encoding/base64"
	"io"
	"os"
	"time"

	"github.com/tsuru/tsuru/auth"
	"gopkg.in/check.v1"
)

func (s *S) TestSamlMetadata(c *check.C) {
	metadata, err := Metadata()
	c.Assert(err, check.IsNil)
	c.Assert(metadata, check.NotNil)
}

func (s *S) TestSamlAuthLoginWithEmptyRequestId(c *check.C) {
	params := make(map[string]string)
	params["nononono"] = "fakevalue"
	scheme := SAMLAuthScheme{}
	scheme.Login(params)
	_, err := scheme.Login(params)
	c.Assert(err, check.Equals, ErrMissingRequestIdError)
}

func (s *S) TestSamlAuthLoginWithInvalidRequestId(c *check.C) {
	params := make(map[string]string)
	params["request_id"] = "0123456789"
	scheme := SAMLAuthScheme{}
	scheme.Login(params)
	_, err := scheme.Login(params)
	c.Assert(err, check.Equals, ErrRequestNotFound)
}

func (s *S) TestSamlAuthLoginWithExpiredRequest(c *check.C) {
	r := request{}
	r.ID = "_b533e78c-9c8f-49c6-4dc0-377dd47ed423"
	r.Creation = time.Now()
	r.Expires = time.Now().Add(1 * time.Second)
	r.Authed = false
	err := s.conn.SAMLRequests().Insert(r)
	c.Assert(err, check.IsNil)
	time.Sleep(2 * time.Second)
	// xml enconded with idp publickey
	xml := base64.StdEncoding.EncodeToString([]byte(readRespFromFile()))
	params := make(map[string]string)
	params["callback"] = "true"
	params["xml"] = xml
	scheme := SAMLAuthScheme{}
	_, err = scheme.Login(params)
	c.Assert(err, check.Equals, ErrRequestNotFound)
}

func readRespFromFile() string {
	buf := bytes.NewBuffer(nil)
	f, _ := os.Open("testdata/resp.xml") // Error handling elided for brevity.
	io.Copy(buf, f)                      // Error handling elided for brevity.
	f.Close()
	return string(buf.Bytes())
}

func (s *S) TestSamlCallbackDecodeXml(c *check.C) {
	//Create request into database
	r := request{}
	r.ID = "_a83cd40f-db9c-4366-6bc0-1171655daf5f"
	r.Creation = time.Now()
	r.Expires = time.Now().Add(3 * 60 * time.Second)
	r.Authed = false
	err := s.conn.SAMLRequests().Insert(r)
	c.Assert(err, check.IsNil)
	//xml encrypted with sp private key (priv.key) and base64 encoded
	b64Xml := "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c2FtbDJwOlJlc3BvbnNlIHhtbG5zOnNhbWwycD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOnByb3RvY29sIiBEZXN0aW5hdGlvbj0iaHR0cDovLzE5Mi4xNjguNTAuNC5uaXAuaW86ODA4MC9hdXRoL3NhbWwiIElEPSJfOGFmNzQxZTc1Y2RkNGNiNTc4ZTlmMDA5NjlkMjkxMGUiIEluUmVzcG9uc2VUbz0iX2E4M2NkNDBmLWRiOWMtNDM2Ni02YmMwLTExNzE2NTVkYWY1ZiIgSXNzdWVJbnN0YW50PSIyMDE1LTEyLTA5VDExOjIxOjQ5Ljg0NloiIFZlcnNpb249IjIuMCI+PHNhbWwyOklzc3VlciB4bWxuczpzYW1sMj0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmFzc2VydGlvbiIgRm9ybWF0PSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6bmFtZWlkLWZvcm1hdDplbnRpdHkiPmh0dHBzOi8vaWRwY2FmZS51c3AuYnIvaWRwL3NoaWJib2xldGg8L3NhbWwyOklzc3Vlcj48c2FtbDJwOlN0YXR1cz48c2FtbDJwOlN0YXR1c0NvZGUgVmFsdWU9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDpzdGF0dXM6U3VjY2VzcyIvPjwvc2FtbDJwOlN0YXR1cz48c2FtbDI6RW5jcnlwdGVkQXNzZXJ0aW9uIHhtbG5zOnNhbWwyPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YXNzZXJ0aW9uIj48eGVuYzpFbmNyeXB0ZWREYXRhIHhtbG5zOnhlbmM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZW5jIyIgSWQ9Il8yMDU2YTU4ZTlkNmQ3Nzg0MjliNGVkMmQ4N2VjNzZhMyIgVHlwZT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8wNC94bWxlbmMjRWxlbWVudCI+PHhlbmM6RW5jcnlwdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZW5jI2FlczEyOC1jYmMiIHhtbG5zOnhlbmM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZW5jIyIvPjxkczpLZXlJbmZvIHhtbG5zOmRzPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48eGVuYzpFbmNyeXB0ZWRLZXkgSWQ9Il83ZmZkN2VhY2RjYjQyYzdlYTFhMmNiZjBkZTc4OTdjNiIgeG1sbnM6eGVuYz0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8wNC94bWxlbmMjIj48eGVuYzpFbmNyeXB0aW9uTWV0aG9kIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8wNC94bWxlbmMjcnNhLW9hZXAtbWdmMXAiIHhtbG5zOnhlbmM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZW5jIyI+PGRzOkRpZ2VzdE1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyNzaGExIiB4bWxuczpkcz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnIyIvPjwveGVuYzpFbmNyeXB0aW9uTWV0aG9kPjxkczpLZXlJbmZvPjxkczpYNTA5RGF0YT48ZHM6WDUwOUNlcnRpZmljYXRlPk1JSURpVENDQW5HZ0F3SUJBZ0lKQVBmcHlteU9OQ2toTUEwR0NTcUdTSWIzRFFFQkN3VUFNRmt4Q3pBSkJnTlZCQVlUQWtKU01SSXcKRUFZRFZRUUhEQWxUWVc4Z1VHRjFiRzh4RERBS0JnTlZCQW9NQTFWVFVERU1NQW9HQTFVRUN3d0RVMVJKTVJvd0dBWURWUVFEREJGawpjM1V5TUdFdVkyTmxMblZ6Y0M1aWNqQWVGdzB4TlRBNU1qVXhPVE16TkRkYUZ3MHlOVEE1TWpJeE9UTXpORGRhTUZreEN6QUpCZ05WCkJBWVRBa0pTTVJJd0VBWURWUVFIREFsVFlXOGdVR0YxYkc4eEREQUtCZ05WQkFvTUExVlRVREVNTUFvR0ExVUVDd3dEVTFSSk1Sb3cKR0FZRFZRUUREQkZrYzNVeU1HRXVZMk5sTG5WemNDNWljakNDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQgpBTXBMaHdGSzFNY2NNTDZ6SFRiaHlaajJKaVpBNnlOMVV1d204cjd1Mk9hY0hQeEN2QUpYZDgrclNRSm5LN29PVzIvNmZ6U3ZCb2ZRCkVWV1dPd0R1L004djdqazNqN0RnQ0RzTFQ5aFJJOUNKVGw1d2hXTmhsQU1yQ2NkN1pvWUZKQjRNQ2grMG1SOTVQWWNBWXpEb1NPSlIKbGdHRE9qL0o2d0Y1bDViV1c3WXAyVE9ueTJscHZLSlNXTGtlVjFwVmVlVU5mdWFhNUdub0dKWVAwUytHaFFsRmNZbnBqNHpSYjhQbQp4SXg5VzdBeUFrMlo2ODBpSEE5Q281dVJTd0VoMVc1VkdzcHBOcURacTMxMWtUcUZPWEoxUGxqMnVwc0RzS0FMVFgyUlY4dEJ3MEZ3Cm5LeUhBbkVsZTdKbWVKcE0wbnpTWnlIS0VMV0FNU3ZvNHJEd25IOENBd0VBQWFOVU1GSXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUIKQURBOEJnTlZIUkVFTlRBemdoQnNiMmR6TG1WNFlXMXdiR1V1WTI5dGdoTnRaWFJ5YVdOekxtVjRZVzF3YkdVdVkyOXRod1RBcUFBQgpod1FLQUFBeU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQWhqaDU5bnhXVE1rdVVvSUNLM3V3eEFCaGlCUTEreWdJN1VQY1E1bnhpClo0ZVlHdjgzd1I0ZjJ4K1F6M3JaWUVvWCtFbkMyWTRyd01JZS9HbnVMWVgxSlVxdXI2bmdEanN5VVB2U3N2ZE55SVpkdlV5V1NpK3QKWEtKUHBnenpZS0NiVHduNzBGeGJzdThBTG5YQ2tJNzFhLzlETkZDczh0MlRFM0N6bC9vcHVRUFBlUTh2K2pQN2haOXFQQTFIY0xxNgo5UE8yY2ZWK096UERDenp2NWJMS0NiQkpQSDgrRnVIK1EvTzk1WjFDOFcwakptTHZrMHhPcXppblMrZ21lYWFaV3draWVEZ2ZaY3R5CmVrMmNESkpxV1ZvejRndmVGckpweHdaUDJFNlltU1JTOEV1QVlNL1pGUUVhaFRXMkRnZ0cvV0I3T3VZNGd3T0xzRDd6bGFzLzwvZHM6WDUwOUNlcnRpZmljYXRlPjwvZHM6WDUwOURhdGE+PC9kczpLZXlJbmZvPjx4ZW5jOkNpcGhlckRhdGEgeG1sbnM6eGVuYz0iaHR0cDovL3d3dy53My5vcmcvMjAwMS8wNC94bWxlbmMjIj48eGVuYzpDaXBoZXJWYWx1ZT5iQzBuSTVGaFZCVVdISEZCakY2QXA1d051SWE3ZS9jcGxBck5ib05SRHZaZXpnNGZGL2dqbmNybSs3ODhSSkVTc3hwT2V6azRJV3FvbkljWVNSNGZIL2t5UmNQc05zQzRORlZxc3E3TnhrajYra0Z0cFFDM0tDdGVYWXZTQzlpMW91aWZUK1dLd3k3ZlFEZU92STk2MWNzY0JDbXBETDZFekJBTVU1cnB0WmJDR0pJRWlmU25LVkQzVnFJc0pDbzhpdG1RQTFvNHh1akVjYkEzNUtNYnVXZDhMYUF5UHkwQlJRZ3F4MFF3NThQeTR5d1ZrQWlSMmlRNHFYWkY2UjRBTGpSRTdEUnhFeEVGeFRIN3NrYWlEMUlPbnloNUZnL2I3NFBsS1h0UU95Ni9NbDdNcGI0a2Z4ZHVlYTRVaXI2cVg5WkE2bWxPRFNGZGxkN1NvUVdQd1E9PTwveGVuYzpDaXBoZXJWYWx1ZT48L3hlbmM6Q2lwaGVyRGF0YT48L3hlbmM6RW5jcnlwdGVkS2V5PjwvZHM6S2V5SW5mbz48eGVuYzpDaXBoZXJEYXRhIHhtbG5zOnhlbmM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZW5jIyI+PHhlbmM6Q2lwaGVyVmFsdWU+cXVwcjFmRUtJQVovdVlHenJxb1IwWjkrZjRtUERmNkVWcEtMRUxhbXBVcDU1aUtOK3E3U2tDSmlQcG9UelA0VkxHUVBRRWJ0aE50T0ROOEM4SE9pdHNwNUNFd25sWUpPeDNjUVZUclB3ektabHl1WmRLeTg5aE54b0lPQTU2ejVObGMwbjFKeFdSaThCckVtMHNQVWhSNHFHM0tQNzVNb2JVQXJvWXBESnBiQ3U3Rm5VaDdFM2ZSRERPMkdUQXVRWWY0NjVYaUl1UnRXWlRQOHFHSFBsV0ZSTElyc2o3ZXNYU0czRmxIZ2lCekhKWThSbnUzakFidE5MRFZmVXZNSUJabmpjRTBzaDBhQkVpRzhYZ0hLK1NhbCtQZklIK1I2elhJelM3M1JWL0RNOFAxWWxqTDc5SUZNYnllUzJydVBkYkVDanl3TzVvMDgwS04wRXpuLzdSVWhQT0dkZzE1WVV4ZmtjK2RVSEJrcjRzSUdvcEYwSWxweS9tVHBIODB3amcrWnJRcHh6eGJXdU9qVTU1TUlzN1l1V21FazFRc0hhVUo4dFZVQStYKy9XYmw3a0Vvb1lkcVAwWFMvcFF4SVgwUjhYcmoxd3h3YXlhRlBHRS9iU2xFczJBSWxNTUlIcUI3YTEyVGFUa0tqaFhTQVZVK3I5b3dZemhTZ2V3SUVzSG9wZW5IdmhXVXVHc3R1YUhRdHpBWDR2N0RMOWR2QkVYUVlNZjZuR0duWC83VHdNMnMxc1pzaVF2NnNnU0NhWng1OGhNTFNaQWovYUY0NE5va21wNVRoRnZOZEtMM05qWHVkNGE1akJrb1hRK2F3WGxJNFhIcG0wbnVSUU9rMTZzZ29xaXZUSzZXV3czQUE0R1lVNmtPMDhQandYWFQzT1l3UVhsVStzSmZGRTRWNkJhRHJvYnBWUXpCckEyQjRDU0FUVjNINWNiRmZabDRjZ3hOeFdCQmplYjBreHlsZnRFS0ppT2VOU1VjWFJSQ3lkMjdOUHBpV1lPckxhTlFWNUh5Q1RHTjAwd3RXMUJKMUx0cFgxY1hSdU5GNVFQSDIva1Vjc201SUh4RHFlekxXRGZhMXdjcjVpNGphVWhiU1VFcHh2YTl3WWE3SGkxUzh6RmltbnFvWW0wV3FuYzZhUUw3Zmg2NnplVjFPTXd6WDB5SXEzNDlTRUV4OXhBcXNuYTMzSWFjQTBOUjBSVnQrVlAvTmxYQ3lEWnhxS0RGWFNuMVBMMFN0bUJhVmdyNGFBTEd2RmtOZmtQemUxUVNBOUU3SU9RSS9DSDU5VTA5dFp2VVNvODh5VUtjTHNVVDlXVDJwR0RrLzVYSi9mbXEvK1paQkZZUldyalVTVUozOE1rbWRwVDhGVmNSSGplVU5EUjZFKzdUM0gxOE1HQnJOaGdTTThNWHpqK3U2dEp6WHZ3YWhDNkJUdHhlTnNGL1dsclJsbU9vbHM3MDFEeGRKSlVxUCtKWWpleXRTQmdIYnpNYTlMWjByanlzOEpCTldYY0hlQVFDZG1PRlVZcVVuSlNMOGo3N1dtQTJxV0Q4Uy9zU3RucGswWVlHUmYycnZoL3NuTjkxbVFOWDVNdEdON3BEK1NMOVFvMG5lRmRaK0w2ZWQyMTMzNjBpWVRjQzBMS1JKV1ZFMzVjQWhPa21MbjR5S2h5SXRNcksvdlEvQUpONS9nY1ZPSVdWNmFrb1JwTnliODZ5cCsvYVFRTTh3ejYyVHFIVzl5OVE3MHl6QWI3cFpvYzB4RGtpWXRta3dyNlIxVnlGTFpoKzhBMVJGaG1NcHNCTmxXYVlGOE1XMjZGdmJ2bG1hMmVQakZ0VFJwQnJ6cndMdUVXNGVTaHZMVG5Wek9pWE5jNTFHZDJrRmpya2RIM05kL3NDZ25tSTNRdmtKSzhxM0ppZWlDOGFtbG5WbUc3ZnlUQTlIa3Z1QmZITXlsVzMxTzZIU0l3dldldnhjUCtyZGw4SlgwZTZ1VUdsOFUwbTJZa2VGelFDZzV4UTQwb29KSWRlUTlJd2ZHcmdLaCtUS200OGxLRkZjdWdXY0hjSS8xeTRlbEJIaEp2V3dqcjZHanE2ZytFdmJOdVY4bDQyL0xldHlZcTJpMWg0d3NLSnhSc3dFZEVBNXd1RE4yeFJvWHoxRHRvS1FrV3NaTGFyc3I0MFlRbUVvcG1ja1ZGbExWN3hKZ0lBNW4rRzNVV09mTkJFYlNzQzFkc21wSWl3VkhZSlFFMkY0MG4zMlRqUllNTjhGb2FxSXdFRTV6Y2dDY1VmQU92UzV0ak9MMnRydGVPOWVrUUdjWE5NMVVCSjJ6WWlYejZnSEkwZnJnMjdBSG4xMzlDRUFDd1RSOHFaM0lUOVh2RFpiZVFFclV5NUpMSmRvZHlvaFpFayt5SnJFQkZvU3pWUFFHdXV0ZU82RFZQVTZPVnFYWXJtU0d1cjBMUGUvUXkrR0IvOU41b2NJQ1N2RC9YUmpyazZzMlN2Tk9jWEZCNlJlVkx6S04wS2N4NnJ1Vmo0cHd6U0UzMTlsUXpDN3MxWXJCZzJCYm9lTnJGYU54cGdsVi9OdDdMWktReUhsNHIxNkhXMkxIazRvNjBCRUplMk9nMGRoRXptV2ppWlp5QUVqalNvekE1RUhwdkVwSjk0T2gxVmdUeDhVdDluc0NleS9HY1R2NjJCU09HdWdYOFQydnJtcVdndm1LV2RPeEdWZ1lEK2pSR29aQ2paUFU3NnUvM1lSQ3R1MTJIU0xzUVVJOVNMS1ltRFlobXVHemRzZHRFWTFEeW5vZko3UzRRK1ZzbmtIeDU1SkU0aVF6QkR0TEhURTRHRUMxMFcrNi91OHJZK2JoNUgzZmVXR0Foa1g0M25lMTRobWtUN2pOQ29RV0lFb0NKd0lPeFVCbEtWWWlUOUs4SWxORU1uOVlSR2dqWGRqcWJCQ3hXamNPUGVUY0Fobk1nbGNSaW9UUnVUV0VhVkFrbHNwTlUwVEowRjQ3d3VEdkpWKy80clNwaHVYaXF1YlgrRVQrM3ZPYkt4OU9pdHhXSFF2NmxCQktZRU5wWW5SYTE1aUNLMGhZRW5RMUs4TWlqdVNiODAyK3czcUtNK0JFSGNJdGtsWUcxODBVN2c5SnhaTmN2NHdBdS90MVIvbUoxOE5hTDM5czVyWWI0MmR2VmRaRmtaaFFCS0FESGlmL3JQQ1FPbktlSU1Ka3k1WDVWa09tbWxmcGR6UXJ1N1pZMFE4OUxQOFBvcDlZdGVYeXlDL3hGRE1SemZOajJhamxVWVdUeTE0NkhzQ0JzWUtxNjN1bmluUFg0RHhnZXhIWldKNFNtd0x2OFMwU1M4Ni9Ielo4TmdmbFlRaGRQTVR2anRQK3EwbXhxc21tNzlpMmRjTmJkY3lwUVlTWDd2VmtMMW5WRFFEOFNYbms2STYzUFIzeEg3Wm5DNEJvNGxwQ25zSk9wRzlmTTIyMXZ2dEsrL3BKYW5CZjRibnVpZVYzQTVySG00MUF0RkhKWUVkb0FqUUFnaUF6azJleTFXaUY5VGtQTXgvcWRUR1k3Z3VsTHpzRDJuTTZYaDR3aThNd0xGK3laOFJIcUVycWJTVHZxWTlRdVBZcEIzSTVVWmQyMHpkWEZmQmFzQXE3RGJmZ0pyODg1bEtPdExja3pGOUI0MFlOMDgwZWphQ2pGbFZjUW00YWllNGxLVTZpSDlWcnFQNGg5OWQzYkN5cndSWDMvYkhhMXBIWkNoRUVSSFpUSUY2V3hCRWl6VUtzc3RFa2Nmd001L2xQZU0zdnFBVUphcFovajgvUGwzaW5EeC9SMkkwZ3plSnpCM3RqTmxkYzZvS2xTSWg4MnZmbTdkUW8rNUU3MTE5SkRyR0k0ci9FZnltQTlYVmRhNXlyeGhpSHhkSFptTGNpcnUxY0JweWxuQzlCZmdTOUtUS3BaRWFSSm56QWo5Qlo2T1QyQm9uSTdRUllWZjNIVkVaMFcxTHdYNUNjVFhCc0UxYjRLbitySnIrRWdFMVMxR0JweWV5TUVLOW1GbnNSV3pramN3MFJHaGU3WGZRcGZtclJlamZCZytFRGhmRnhaZXVRdjZDenV4a0FwdnI5UHg0ODVkVThnR1VPWGhYMTFqMnBBamJMYlBzcEY5YWFaeFJrUlh0aVEyVkFLdytIR0RvS3B3MDV4b0JoaUpSUUNHclI3MUEwSnRnSWR6MC9PKzFzUTdpVUZxaEIvS1R2SWl5QjYyQTg5Mm5xdHU0YmlnaUJqcDdPWHBLdGZ6Ymt4c1RvanY5aWpyNFljd3ppN1RRcUtUcGlhNEQzVldnRmpxNTkrMVpJRUJqQVhPNWVuYTRQZUVJdEpZYmJIMFp6MjlSSERaMnh2NFY5NndSU09lTzRFdmNVNHBVV284MHpVYW9aMW5LWnZPamhtbk1jYmZEaUswN01xL2IvRzhKNHM3bkVTb0wyVUF1cGRuR1MyNmhmWXZQMjluK2Erc1BtWGdFM2hLV2NvR1JmWnRYNXRSNmllNjVsL3dvYXBvK1lJaDFjdFRlc1RDQXJOWDQyVFlwK2MzTlp1cEFSRFhsZHBVSnVoY3J5S3Y0WWI4SW9zTGxGbUNjc2tPVjZyY04ySklmNG9PbnNXYUZKREtZa1lCVjZlQUJqK0xOaXNDeWFUcndVc0s1c1drVFg0NWJFSnM4UWpEUFNibmRnNkJ0eWhwQ2NQMmJOR0dScFJEanVBYmxnTFFpMUxCTzZ6NzdENDcwanZBLzA1d0pxMmdpSGpVVHpVRlY2aVZQOG1UdlJqYUcvOFd5S1YvaXRMZ29VczY4eDZvbEk1dGpVUzFoam9EQU03Qm1TM1VCOWRNWEY1cEgyeHpZbURqaXZqb3FOa0lRRDY5VHowaDN2SW9UQk8wQUxlR2FLZVBrQ0k5d1hOK1NnMnhIWjdZRzFjZEtXaXdRTnh1ZFhNSndxbjBWUzkyNWFudWlzTktTN2FOQjc5QUxoSS92ME5DT25xc1czbkQzZWNHdDBtdXdvNktyTFhCY3BYWFQ4VHVCM1QyOEY3d1RITTE4RjJvd0NxQzhrZE03dnAvbW11eThZeVdRS3FnMFNSeDY0NFBLcEtZK3c0TGZEcmttRWJmS2Q2dlZFOEpSMXp0QmM1ellDMkJtalBMUmVucEtBTGFYWEVMSUZERE1xaENtQmc4TXRCdzM5MTMxQ0VJTThYUHlKN25NNHBxc0xEZFo4YlB0djJRYU1OVXJFeG1hN0RUWktoZnFxUDJiKzVlWHhWRWN4Z1A2eStNN3V1cjIrMzUrdTFDaTVtV1VBTFRTdW52RTVqbVJyQVFvNURyek9tdC9GYjFGWGtHK2RBUTVMY2JxZ2lQaTZYVE53N3B2Z0xnKzlvK0kyTThQOC9zeitMaEFzdlFxYU5CZHFvQXpuYXJoZVJ0RitYWkQvVm9EVXg2aCtXV2p0NE1udUNvN3RCTDl3K1pOWmZKMWE3Rnp4VThlVUxHdDRxb2VxUTRYYU5NejB4TEJJc2V2ZzdLbzZOTk1PYW9VUTRpT2JJVGcyUVhVdDFLdlFoL25JeHk4Vk1iTGhqTFdtMitlMzRSM3Y3NG9ydWNhLy94OXdnL25rSHphYXo0TVFhY2x2ZzBnbkIxKzk2SzlsTkxBb3F5a3lLUkVqYmdOZ3diYk9id3FUWHNka1NiOHUyeER2REJrdXdiTENvTm1nc2k0c2JUVUxtQkc1TFdxRXFCS0FFYlZMMlFrL2NJRnVMYktITkljUEdPRy9tWEhIeFNCcUhPWHNIT000bDR4cW5CdXppMDAzMmpTQ3F5NkxxMzh5MmZVRE43elBBVjNkVHdXUHJSTUZFNnNZNGR0TmVhb0REZHBDWXV4NTAxNllwWG1QR0FyUkx1OU00b0J4OXVUSjBYa2w0WFczMWNtaDBDT2JrY3ZJY0Uxd0I5RWxqbkJrTUI1dk0vUG1nZHV1NHVMdWY1dXlaaHRhQkwxWWUrcGNpaStDY2Q5QTZ0NjRMWXN0OGxDVjd6VUpkMVZWSE1LRmVZdS9NSTZMMGNUYzJsZklNNTFNM2piU3FDbDMxenp2eEJ2L0Yzb29ndUEyT2ZBYnVIT2V1alhnckNhZjFKaU1UdXRTRU9OdHlSRGNZR3hWaCtMSy9SdUpmOUk2dDR2RUtsdUoyRlVtaVBrNGwwVnFkbFkvNmRiRzkzTEJoUkhNRTluOVN6dVNoa0NMcFFQc0Y4MDF0THJNMUErdjBTRkM3QzNMb01pK1VXUDJkSGtPOVBmZW1wYlhJRHJOdUVYRXlTV0wyWDlGM0l0M3FyZUx5TFpva0NRaUd2eUJjUVRBeG5laWRiRUdNK0c1cC9uWmd2UjF1YjdxRjBFenNQa0dLenVZbGY3ZTZEVlpMYXorV28vVkg1cENvRnJLSHZxT0lhckxKdFR0NS9IQk95dmpTUmg2TUdLYm5pSXZhVEFIeitWQUpSRnZYYjBpV01KdHUxR2l3MGNDYXAyYTdtOXI2NE9KeXdoVEpHNVVOU1RYdEFJTytlOUx0cUplc0hnYUZaU2ttbXNPc094OFpoRlFzQkZKMCtYeEhJb3BMSGVDMmV6RzEzTGNUdXJUK1lKeUNSd0hoalEyRkJSaGxxQ1lRQTVXKzNtRHR2bVMwWWxJZFU5Z2o4b251MDE3TTZZTVFXZVJEaXVtRElvT1czTk4rMkhWUUlnZDYyd0hXOTJINVdlcU91b0dZR3Zud0hLZ1UvWFp6cFpRbE84N3NzQU5UalJsT2Y0QUg4Y3ZlUkc3MHBpb1B2QTRFQnBvb2lhU1dtdTVzbHZDQ3NJTXRwMS9XY2Q4eENoOXpYSVRnVHVVRjFINHF6b2lIV2h3eDM1eDMyWVpIVXBveWxCL3FYM1graHpRRk1HZFN6K2M0WGNHNnkzNGV1cjh6TytmUUtVZXY0K2xxRkJ3SEFZbGgwNCsyQVlZV0U5clIvaGdJdmZUbFB4VW1lekNMV05aT1RvbHlZWmFPb2tycUFyMjhnbzUrdTV1d3JaWXl6T2xtVGx5azNMYXlSOGFqTDJoR0VWNk5GOWFOTnZlSjhkY3RiYnhSVUZDbU1TNllLbnV5RTlBejdOWU5vaDM4bHluMm5HelhUUzFsV3BPd3M4K2lwbnZHWHRPQktuRytxb2lRWDVUak9Uam94Z3YrZnMvY0dLZFF3bjlCTm5OZTY0b3A1U1RvakM4dmw5T3ZzRitlMGZBbG9zZUZET0o5RDZybGswNTN1SUlJNFhWWDRXQi9qZExpSHQxRWw0RDdxV09FMnR1L2tPZVdaYTZHRnlBR0dyZ0IwOWRpUFpaK2VhOE83WjVkOG8yMnpiblNBMG5QL0pTcThkbWJiUHhYWm9iWUdYcEZCQXpTZUtETHpFdUJ0S2FXQ0YrcjJsRHRENmlpaWE4Vm9JMXRuUXIzSmZ0d3pQU3dkN1Q1M1lkdDdjbUNoSHJrOS91VjVaMXNMcmt3d3BjVFRCeTFlSm4vRk1od2t4Znk4SXc5OWFYUGhQSEMvVkcxZksvMjZSbjVQUUdRbnFNbXNvaGFKSVJIa3VsUktoYklscGU5a3pNZ3RqODRINCtFbmkvUlhUOU45cWh5dkVFTm9mZmxWUktJY3pTMjdOeGI1WVQwbmdPOW5JMkdMaEQwV0lncVlMMG5wbDUzRDB2TU1oQUo3NHBsMHhFdXZaaVI4UU9WY2plZTlUWjc5WmR3cmFhTTYxK0dmS3BOR3F1Z1MyQnBoMkRFc1c4ZHFyNDJKL0M4ZjZsTjVwM1pTR296Q2lTK0NlNndMYkprcEtiMHE3Mk5SYXBKZHE2U0lONjhTb1E0aDlqR2xKMGtZa21nRTdyNjJhZ0oraGxUWWplVTlhVTBGbzVWLzBnY1JXOVZtUWpGdUV4SVVBUVlBZ2tYNms4a2M1M0hqVFJpVlIvV2RaWDRqaWVsOE44UXN0K1hld1QyczlkdE01VDhSYkVIZm5YdHduSDR3N0hWU0dVSEMrSCtCQzk0Z1J4YldmQ3BBam9QQU50STQxM2FhcmFpRFFRMzhPY0ZZS3p4MzQ4bHhqZ2ZlRm44YUhaOWM5L2w1cDZiRlZEZmpNejFNOWRHb0syNFdXMlpoZ0FQNFZRbjZabjVDMmE4a2ppK0xTdVd0d1dsdTBLU2pPd1FVZ2RSdGNpYnBIeVJEa0JrbTRWZ3grbmVLU1pXZlF5dDJFamRFd2R5QTlTZGF1SlluV0JZSzRKOU1CT1B4b1UvdHBIWDRZakRTZExZVzNLWXZmQzFuMFJZQi9PNUFsRHdrc1oydlpFSzZJeWUrUFZTWC9ac2NHOWJKc0dieFR2QWxBeENPcngyWnlSVWlNRldrbTgxc3lNSmpIam5nQVNRYXVNSU9IVVZuZXRkZlhqbFBnOTJZeWRjUjNaUEJya250Q2lJUFNjZXNzNWFPdWJWdVNKN0tDcXpvcGs1UFRxRDZwKyttRm9nSmtQdmlRbDd3Q3IrU2h2TjE0eEU2bnp5c1Y0TVJla2o0Q2UxY05mNEo4N0hSU1Z2VWxjcXY1dWNsZzVPQ3pxOXFiUFYzMkwwWHdZM2FzTUdORUJ6UllxVUtrZXhJSnlQTXJpK1I0T253YVc4WVZDNDdBQ3kwVEtsaVBRQlFZN1IrbFVlbXVBVVVmUEZoR2hTblo0VE95RXdVcWE5NGhWU0pIdUFUMHRBdHZ1UlIxL0Q2bzljRXIyNkh1ZjV3VFQxYi9HQkoyZGE1OC95NFhDbWw1QUxFQjBlNGxwYnpINFRCcGlhVm9wKzZqL3daaDVHQmtRcHA0MDFsNHU5OVpIT1dheURvTUtPNis4eFVvU1loU1R3M1BnN1hrN3FKZml0eHB3WUlDREsrcW5sVFlpeGtmVEZyRVdaVFI4WUl2ZU8vMzA4YWwwMTlzYnVFdDFlTmtyRDNNZG1NRURHd0JiMDJlUzBlSjBqZnJUMnl5aDVMWEFwK21yM1BqRHpQU1RVSTgzVTJhYjJvZWNEMmxMeU9DRGVsZ1RIWFRvZXRwZGVvUTNyNldZVkhsZi9Wd1g1bmdYcWp2ZzV1UW53L0lHWlBqU3VMUVZ5K3NqeTgyYXhVWkpidHFuaHdiZTUvNTNoL2FsSjVhOCthWEhtMVZvNUdNc3h0ZzNHTVUySG5hZG5sUjFmbVdVb2E4M1cyTmJPSFpPdFhIUHZOR2t6VTQ5RzhsVU9WK0NnY01NUFRWTTFEc2tFVFltV2E2eE9hZlBtcUF0amlVUGlVSVRNbXRDbWVXYXhoSE9Bb2E2TGFzMGlBeEF0NDNuVTBjRHZ2MTFDa0JjelJyVzU0a3BaN2FJWmFpb0ZhRmFndi84MndwRWtLRG9HeXlXKzNTNnVxR2F3NnpRMjExZHhDT2U3cEJvK2RHQlNjcW5qMmVKOTE2Ym42OFAwYkdNQVdSRTc5UVNQTVVpVU9KZWNHaUEvamRxTE5YTW90S0VGYWdyTnJibmFUZ2Fxb3BSdUtWT3dsUGVId05KZHFRSnBvOVFGN3hjdzhXMFZYS3ZHYmgzMVQ5blBTZE1SblFRaFpMckQrbmVOeDFZY1lEcFlLSlRIb2h0NU1pWVZuNTR0bFdsRHJEeWxzVnFjZmtHUitlbGpHQWFlc1ZuZFRPcUVubENHemVPNnZ2Sy9VOW1tK3FvM2ZwV3ZTM0tDb2ZzOGhVTTM1SWZQSE1Wb3pzejFidENaTWlXMkFxbjNHMjdyN1VGc2JkRUFsWXU2RjBKaWtRRlBFY0xIdTBhWCtoMmxSREVWREM0ZFdwOEJnZ1ZTMnY5UENmUmEzSmM1R2liZncvSFg5VFJjZEFWODI5M1BFSUVOQkl2dmJLQTRNTnZIV1dHT3o4MDNqaEtUN1AvUFpVa0lDbXFFYUdmRHQ3Rm94L3NLTU1RWDlURWk5Nk9IUTlDZFZIbzhaaTZDVFJxLy94cDY0QSt6VTJBTjZmeWZIMTZRWkhrVXlOVmZEZ0ttU1F0emlWR29sZ1MyblY2UWlHYlRQRGt6NTJ1OVpVTnl6aW1mSGpPbGtLY1NNSE5XU3QwVXhHTEZ2dDIrZVl5YU1jYk0ra0tzT2p4eFI1MzRsKzRwZkF0OGt0Y3VhdlV2b1pubjlzNXJLdEFnK2MvVGp0YXJNcTBUdDFnaU91bmtSSnZhZ3VDVTFYbU9LSWZkZ1p3Wi9ZYzZ6bnYvaGdBRFJiY3MwNEd3akNWK1BNenUzM2k3dzZsd2c0RUMzeG93RUVBamZyd0QxdXpOUEFuME9HTFpjVi9JYWh1bnRybjdKa0xmOGFaNGdXeTJGMit1dThZUW1Gb3RUOU5nbm9GakV4YVFiY2szKy80VWR3RlNYcVFaeW1RazR5RkZERzJWNkZhV0FFSW1rcm1SUjV4OFhOaWowT0RSWCtHN3JSQkxDQ1pRQytLY0llQWgyQlROMVpyTUZNQk5rVFBLUytOeGZRTHYvTzh6anFLcytWYmFwVlRTMDFtcnU1TVN5VTRoR2p5a2FHdnAwSTg4MnZ3TUFNSStpY0JWT1AwcmljUjJTRTBQMVBPbHQ3TE1haTJHUDZmMDVPQWJ5Vkg3WXZFV3ZzenFuS0JaY25MNC9CTjRtZ2NEb0ZtbVBZUGdlZTk0TkR2Q1M5TmN2Yy9NWGVtMTFzelBhSTMyWUFQY0tlUmZkNVEzRmZjOW9ReWJVVlUvQmh6SkdUelI4ck83b0lBdzBMUHdtWFBhYmZuYXkyZERMQVFoQVhtdElueWVCVmVBTloxUy92U3BwMHAzWDVzL3phYndvYXVOTEhYUHpKdXdDcm1XazRieGVwWTEzRjg3TkZ0QXd1NHdDQVRaa2Z6RUhHUjRYUzBNZHRMUWxvOVVFZnZFOTZadis2NzNuUjJpSVhrMzVJYUQvQWRqNStWZUZleEdVOUorYXRVblljRUQzVmNpNEZ4eFQwU3VPQWtTMkQxUUNEQjdpaGZQblhtelNmOC9YUDFRQXlSMTFkRWdpN3F1R0wwaFhpck5IU0xleUo1UjhnSEVaWDBLYjh3Qk1FemcrSnhYVUsvZDhWL1EzOWJRMnhZVTYxcmdOKzE4R2EyL09xNWNuUW90Q09Ld1hEK2ZGMTVrQUZOQUI1ZTc5L0hJK1l0UlN5RXorSTFpZ0JWWW41Rkh0aVVzNXJZdUlHY3ZvZVFBTVZxMVFSSXJkd25oS284UmRxQTlUNWRZL0NWRzR5dG1UUXJ1QmIwdEp0Y0VraklxTzNpaFFBeW85a2JRVWFUQjJiM1doV3I2Q1ZUbDAyUkQ0S0hmenpiYkVaMnQwYkx2dGk1aHk3aXRHZUpMSzZrL0x0cVlHZ25nV2JjYWNncmhpTzh1VWFoSjZrdGtJK2xYNXltNjJudHVyekR2ajZCQWN5R1Q4ME9PU3JPWlNnbnRobldYM2JZVEVGYjFhdUNIeWpJeUc4MHJaSmorbW1SS2RjSk5COU4rOVB6cERjbklVSFNuZzFsRHZaaHc1MnJSU250TC85YVFpdndxV1hFYzhNaklMSDgyQlFNQU0xKzNNcDlqUWNXUzBWZjc0ZDVHU2VvSjZOa3dBNUE1NDJYckxjZmRrTVVjdnU3ZDkzdm52S0t1cmdOZE5TWmJBZCtGMGh6UUN3aFRUQ2FoTEtkQXJIQk80aldQblNCTFgvQ0V2aHFvbVFwK1pQTlhQZHlnYTdBekgvYklnektnVHI5dUZ3b1ZaYks0VnFDVWZUZHk3b0Q3K0hOMURHNGFKeWxMdllBYWtZdmN2R29Fb2pEVjdWMUFjejlScFJySjN1T3ZBTWE1M0xRVU9KK0FuY1BvTnFFdUlRRTRPYW9LK3VOMGJoNmFXZnUydVFNMUdBUllET3gxN2lVRkhBRTROMzhycVN4UnVoeU5HYXl6anQwOCs4WUFrVnZBMTRPcnFjaXVlSWpGMTRBek0ydnNjeEJLdHRqL1k3TFAyYmQ4dE04VW5NUU9yWlFOeGNqTm4zZU9MakJpamdabjl4Y3h1cUduTzlPd3BobzhGdzlUU0Y5WkhjL0tFOHdNbkdWOGpaVTViWkE5V1RLQWN1MWZscklFT25ZSXlTWS9BY3NscXo3U0YvOFFiK0tVUzcwd1M5VjM1VmN3cGhTL2dpc0p3WUxkcGd1SVptY1VOVkVid0ZZUXY4OWhYekVoZnJSbVdJZ0U3Z1NKYlJ4RWhXOWtwdEg5V0tXRU95b01GcGF3Nzc2TkRDNEJORk5pVUVDTzBRMFdSUk4yQXJTVlVMOXh3Mmc3eGh0amRlaU5hVkY4ZVo3a0sxMHJ2em1qc2xqNEt4Ti9ZVTBiSzZXeUxjemtDTk1aY1Y1MEZKQ2laRHM2TXc2bmJqcHlKbHA3ZUdXZStWc0RNNC90UTZFa1FMTWpxVzdxWTZLNUdyZGp0OG80QStLeVA0dXVXZzZEUlpYYkYzcjd5MzhFdy9lM1pucWFqbkVqN1BybnVBNGN4MVNQcnMwYmthcGdSd1ppZGtHczR5Yk9uZ0NGRU84RndZT05rQmx6bVZxanhJUmh0QTJhNzBGZzNCY0xkeUJUb05MNGRQMjlvRXpHREN6R2RZSlc3R3lMQXZnVksrZVFoVmhZbFZ4VU1wUjYrMjE4WkhKYVAxaGEzblRyYlN5cFJqQzFSdXFpTmJhTzhhVTg0bHNleXo5Ny93MW5zMUZJOWl3UlZTSkFGbVdZTFdXb0lMQ2o2SEVWSGlRa1dKNkdKYVFGRGlOSkV4NThOUlR1NXJVNGd0ZC9kb1RsSWNSR1U5aHFMNE9UMWxVWDVpeTcxbDk2VUp1czduS3BJdzdRYnBIRmZnbXliKzlFV0tDZ08wUlAyeFRleEtUZSswanoxNHdLbjJCT1JDZkVUMS9OZ1JVNU9EQlQ0SjdqbHZXR0NIU3NvYTYzd2xjeEpVb0VTZTdYYjJwd0dVQ2VjZFhJK1RydTVDRUI5a2g2Sm41emFra0pBYTUrZFpQRFRCN0UyMEZPejNkVllUczdHSkFuQmJQQ2Q1UC9FNnNpdzNJRkRnaXl4UTJERlZ3eEtCYXhIVkE3Vk1yWGhzNzZaMG40NFhGMVM4SG9RNE81L3ZITU9hN0MrcGFPNllEd3ZHWVpGeW80YVN2YnUyam0yZ29haWZENm1ueFVVc0JCeWVDNUNPb2d0R0NWOWNJbUgwUFhpSWRlRThHTU02cEIzUjhiMHFFdkVBZDdxdnk5R1krTlVMWHJjc3hTdFBwL3JEVzFnV0lGS0hmVmNmVmhYYmpMczlVaHdlMGlwVjNvT01obkx4Sys5QU44RTZVNGRmdHlOWVArYWlNSGM5TmFOazNjUlJhMXg0TzNTelJocDZtMS93VnROR0RoVkd1aEZ3SzE2WTk2YS93amR1WlpQVmY1WDIyWXdqalFmR3U4ZXN4L1BjNkdNV0hNVVFaakppcHBxUUZjcUcrM3g1TUxhelpCUFp1aFdYdHFmS05BSWFubzg2cXJidXA2bnJKb0lZYk5jQURpdUlQSm53NTA4SWllMFJUNDVyRS9RQVJFZStUS3RQYUM5QWhuUnl1MW1mVDhoaW5VUmtRTkIwdkVQVUw0M1BYMFhTK25DdndoTFBYSXQycG1sTjI2eE5PRnovZHA1V21aT25jVHFQMkZIR3lmekxSV2h5bmZJNFlHM2tteWVwaEpXUUtUQ2RjYnhDSCtkOFZ3eW5YTWVNRUVHNmZhRlVZOGFIVllYVUVGVVhDSVpDSDRtWVNiVzMrSGthcGo0QWREN0xZZ0ZYME9BcmZxVWZ0SHZEMW1yVXdCblIxZzBuKzA0QytNNFNrRm1YbXNteEVkZVBCTUpqbTFGbWxRL3J2K24yK0EwdWVlTXlyM1V4Q3pvMDhwTXFDclZFK09SN0h6Q0taTzZ2VVVvTkNlenFwZkFoUkhYbE9hN0tkd05CWGt3OFBFb0IxcDh6Z1pMZDVPeC9yVzZ2NGd4SDc4ZEhKenF6WnViZ0Z0eWZHMXVkcmxHa0JnZE95Qnk1NS80a1BLazJyL0F5Sm1EMXB0aWRHWXhzM3JFRjJ3eEN6a0xyK21XejhmckhXaXhSWjN2bzlPdGZyeVZZQ2VIVWhKclJTSXZGRkhIYTBXR1ZqWE10OTZGemwwUFozMG1EZmVGY1BtalJLeGs3RU1zRk1PSUZMeVdmaUFjN3p1ZG5iSDR0U3NGMlIwSFJacjgrTkZ5WmpkOE9nU3JIS2pVY3NyazBWUEUxVE1jUGlCdC9XVWNpVmN3aGM5aVJEUURrY3dCN1ZGbXp0WW9TNlBpWXhIVDh3ZzFaZk1ENTBMUVJjdzNJMk9oeXFiR1h3L2ZjZERDd3ZyUEgzTUZHRnpDRkNFZ25jOVhFOUY5VGR3ZzQ4ZXczV3R1Q1VIMVgwQ25uTnZiVUVlejBIRlM3TEx2UWV0dEdkMzZzRUhqd3g0VGhRN3oya3pVUHVicHd3TVZmdWRoV0F4c2pzUUtYN1Y3UGRtMzdjWncrTU9VNGNWeVU1c1YvU04zWTh4a1hWUFFqTXlhV3UycmhkVGU5bC9zRmdBQlZKNVhyWGhVWGFBdmlDR01ncXgvNmhSYXdjYno5eXl5RlRsRFdvcjJIV1pOOHhtRHU4dzNKZnA0Y3lvMUVpNGF4TWJUUGZhcm1XR2JTSkFRVFZqaEJkVnBOYnJjUGFKM3V4dlFSUS9VdncxNHdZZnd3aHRZeFZvOTEyTzArZWZQeWE5Tzk2SEtmRlNhSU5kMjN1Ny8xcjBHVHN6NUEzQ3dDZ1pCMjc4c3JpUjBDdTlMa2xuZU1QS0s3Nlo3c2gybm5BZDIyVVJCUDNPci9vYkRlMUI2bE9ZUEswcjZGMGZlTDZzano4bitEUEpYdFgyVndPSjNCNjhZUlFYSURsSStlcE4vaHZTeFl2UTJYSGllekNUU0dOOWpFSnQ5aUNaRURSalpBWEhHM2tLeno2N2NUNE9ESWlTVkFDZUYwandTc1E0NEhhcVpwZ1k5QXdMSUVMNWxtUUMyamc1TzZnNTlFcFZnQncxUVNBME9Tbm9HbnBzVmxmaUNmMlZmekRrQ2FKTjV0YWF1eTg1K3hOT0dkMkF2bkhkVFNMNnA0U2tvQXBydDFTRGF4TU9pcjFZbFluNXhrVVhzL2VYdklwY0grT2dTV1g0MXdOSThLWGQ0MWhhUFhYbmJja005blRDY1JiQ1Uxcm9tMkgxMlJ6YkFFbmhtTlhwaDJXSCtPRENSaUV5VnlIK05HTnk1c29MOWh4STBvbXFyK3VxZjV3dVVkMDBPek4rcHR2eFpVbkhJVGtUQVM0TUtaM3F3R0lqMFA5NGVGWlF5N2ZHNzU1SFNUZ3dKYzRGcS9VWmFVeWY5OXg3U2R4YlZyYVlXbVFpS2plM0R2MG1IZDhqU0hGWk5FWWJ0cHBsK2xhV3BJOWU4YVV0Z3VnK21uakFPVGFkZ0hpVkQ1US9GdlJ5UUNsVjZvUUV4cXdDVEVXNnk4L1p0UHJyTEQra0dhaUpXM0lGV2hZOEQrY0x1Y1pqQkJ2cTNldVdDdUR6SG1UdzEydDRiZ2JQZ1JsczlCayt5YnB6VllxU0dkSXBpQUlYOFBFVEdsanJHMWQrYUlSTzRDdGQ5dmx6VlVGN1NvYTlidlVkdXdLcjJOMTlPY2VIWGtzZVZrcXdaL01PcCtKSjJsSkVHWHg3eVZnd0x6bFNEZ2UzWTZkT1lEZ0piNjdVa2FZR2lETUwybnZ4clpXTzIwbmp5Wmp0SmhzK1dMaCtZa29tWjFnelYwUEJIcytYYVRTSDlGN2t0R3lqYzdqUmFqQlJEUDZmRTdGLytwTDJPbk5YRUJ0UFlRVEp3RVk5QmF5cGFEOHhUSzVIaUhWREVXYzlCY2lZR2lXMEJZUHpwQnF5MHc1VnlPMUlxT2hTcXBGMmFaZTIwVlp2ckk5L3pEUC9lK2NMWjNJYk0xN2xTY2JQaWhjNEJtdUxGaWE5VW14ckRiZkVhdGtvVHRaSW5oL25VQ2NaUjZHa0x1L3g4SmU2RitMZWtKR1V1L1M1RzhIQUJpYTFMaFNDWXdaQ2Z4RGx1NUxQTFkzbmZaS1cxbmQ3UE9jV2RraEVicHVZYWRTSU5FSFVsZTROKzgzSm9DUXFITzk4bTU1VnFKVWpwclFxVks2QzlQcW5hMXNEc3Y1bXJ5VnhlaG9mMDI4RUp0Q2ZQT24xVlkzcENlblcyeEkrcStlZlVLZVpodG8xeCtSR01lYlVBTjB2R0tndE9LUS91QXY1bzN3a3M2b3I0SG01K290dkttcStzQ1NydDVtYUs5R1k4RXlKSm1Ud1BPMWxxdmNXVndQaGRSZE95YWc5YmcxOUs1bGs0MUhTMHlqQXdHQ293VUJDbFpoWkhvWmN4L0VLVVFTWXlKSzdaZDljbTVXek0rMVFvdVJ2SlNOM28wbmR3ZjF4VFd2TVdZQUI5SjZLbXNlM3NNMHJ6dmEyblpSRG5xOFpJQTFVTENiSzdOTXBnYk83eU5sNFRLYkJOQnNBU1dwSGZQSXFmRllZZDQxRjBZQXhmOTE3ZXJJd2l2MGhqNytqSFVMa05ZQlROSk1pVUpJWW5ZN1ZnSmRrQUJ5R1l2T1VadHB6czBlck5lWG9yNVZSU085VUVVVzAyMWVKemF6ZmFtdFZDK2hVRnRnbXd4bkJwZ3dkU3JYdkk2SXFtMFdPU2w2RnJkenRuQm12Vm83LzhyQlRYc2JJV25wT1hxVU9SZmJNTkRpd2F4S2hIS1VKV3U3TmVtUUNMWERjaVM4WEtTMFpMcUZTVGdlUVVldEV0Wm9yR3ovdVg4MlBISjMzZEp5WlNoOWUrVTk0bXZhbDJHbE02b3hvbGpYVzk0ZVc0ZXhuTjNqU1E5enBQTlpselhxdWZvV2dsN2hzMVFjME8xVU1rMHlQRTlpSzdQZlNYMlRiRDYweTJSNU9qQlZmY3FNTERNM0RPdlhDTWwwRFF1cm5jOEtPaTRqSHMzM0MrNkVFeHZnTWJ3ZTNBZXVYaXdSaGkweWZ1Nm1rd1dXM3NZY28wZHEySExBanFwbGRZeTFMM3o5blpNdUxZSFR6bXBSUVFwSC9seVFCQTJGM0tjY21rcU9MTTRKYmorRW9YQjJqL01aOGpZRHNFZGVzaDBRQ3hIWXJJQmFPaEhxelhabTJ6SDZ5UnpuSHpkci9BakNLbzZ1UkNpTW1qb0lmK0VPeVVWcXFoTDg4MHBza21VbUFaYXEvazNjTnZZQXdyQy94UFl3L2k4MFUyYkVtZlZMc2NKMGtqWUhTK21nRGtpc2JIZllwVzdjdWxvbmY4ejFid3JYV1U1RTZNeStzeDNOallNQklTSzhMZWFtUGZHZGJGR1RJZjJRWXZ2ak4yNk5ONTl6R05Ma2hLbVR5bjlpOENsbEJJYlVvSURuTXlBTTdza0RSRHhOU0ttMGQ5YStZOWJ3MmQxeW5YUm80Rm85MmdwdWp0TVp5bzBZcHRrTVVHb3k0RXM5cjFTMEhGWGVWUmI4dHJNYzNqOFdHYzZXM3NUMUdtUEVxUktPNU45KzF4ZDNnN1B1bTVQNWhEOXoxWGlIb3BrL1dqQWFaUmMxUEdPMXVyQzhkMjZBY2Erb2pHeGlsdFlSY0FnUFBYN0tPMDVqUGlZdWtyUlZnbDlZY1AxYkc1SklHZWl5RUxwQmpHMmhYS0poTHh0eitNUnhKbGRadVEzaThpOGdnUWFJUXdrWGc5RlRBZDJIdWtldDJYMVF5WVpXZ1ZOdlBIcG9JeDNhcEJ6TjZJR1Ivb3B0d0VsZ25uaSttY3lBMytVVUdPUU44Rno0eVJwNkZnUTZnWTk1V1ZuemlCMTN0STJFdzhFTTBOSUNiT210RFdIVHBZVC8zcnZkd3hEY3VWODdzQm9GTWpVWnNZWXY2THFveUV1UnY2bmhZbUhPbFF5WExHeEg0MXFLVlRKSVZMOXVObWVMbVRvQjdNM3hweXpzcFkwTEdYTlV3UUpmSWFDNDdiU3V4SVo5RnpiVlFTVGtTcjAvbmJCY2EwVHdISFlJWDhFVndNTisveEF1RnczK3NnTEUyVG1iS0phSXg1azBSaUdkcXd1dGU0VU5Fcm1yVVV6MkphY09halF6dUhFSkZ2VVVBL2d0eEpNODJNS3NIdUZJQ0xhWW5HUnpDYkxDclcrOVNhajBxMUsybUtVdkM4Y2duSW9IQ0Vlc01rRlpKeXpEZnNlSDYyanIzQ2d6cmU3ZTEyc2k3ZmxKa2J1K3NzcTBYWk9rYWhXSTM2ZWVQMHpjaG8rMkN2eFZYVU1xcXU4ejVTL0s2YWh0aUJvYndjN1NzMkVKbkxzb1BmdzBaNHNVWGpVY1V2eEh2L1kvZU5BcWZvcU5BRVFRQUhjZzlaRTd4NUNRb2NUT1A0U0xmQlI5cDZRTnNFZ1BmbXpiN0RVVmRMZTk1MVZHeTlSV05OVzdqOS9yWWlaaWdoTDRWc0FpWlFuUUFhak9GSUNFQVo4MWR2Z3RRd0EzejBTUkZUMXpuYXJONnhrd081akVoN1lWRTI4RVJNNHUrSUs4R2Jmdjdoeis5ZUNqQVdVV0w0WHNZS0U2ZDkzemdXbjkxbXN4V0NqMTdIQkMwVVREcTFlSEtXRkRHc0hhbWoyRTRUVFBIN2MzSjJ3eHAyQnlhVlBFbHBXeXBlQ0tRTmxObXNtNWgrZWFxTnhRRjBBU2Y4cW9qU1Q0QStFbklDM3RQVFlkeGFBd0kxbUJtYUwxZ0tYb0R2dlEyelNGakc2QUpIY2RiWDNxZm5USzlHanJnTFBmWGxwRyt6V2VLck9LSmtpUEt0SEtZaEVaKzQyaUlIZU43MllTQ1hpM0NPVG5pN2tHZFFwWHJ5S240c0xzNWFkTjYza0pjam1mVXFqZW84aXh2SmlReTRuck5nd1kzbHJBZ085SVk0L3ZLMDhmNjNnUXZCdFpGaXJiM0RWUXdUUlZnT0ZzVG9TN2o2aVRvdUtsRG40UGtodFdqdVNYaWNKYm5IUDVUZEZ1ekRMSkNMMElodGM4OExOWXFFdnlLR01NUTJVamRvdHFXTmR5a2h5dXVweDhlWEIyUDh0YzZjTG5NVnZ2N2piT3hNZTRGVnZzVkFsemlreW9qb2FhK3lYTWVPWUZBV0M1YVVOUmJubEo4QWZWWExzYW40bXhUeEJRTmtLaTNJaFR4MWVNZ2RldURJczZzUjRqeHlQakxpYzlEYWJ4aHdRdEZEUmJQZmpuSURXUzlSM0Ztb1A3MWhjODFqQ3JyMVlnbjU3ZWhGa08zY1VpS3Ric0NLK2RLZjNBRFRxbXd5L1hIOW1LbjVJQUhRTTwveGVuYzpDaXBoZXJWYWx1ZT48L3hlbmM6Q2lwaGVyRGF0YT48L3hlbmM6RW5jcnlwdGVkRGF0YT48L3NhbWwyOkVuY3J5cHRlZEFzc2VydGlvbj48L3NhbWwycDpSZXNwb25zZT4="
	scheme := SAMLAuthScheme{}
	//Parse xml
	response, err := scheme.Parse(b64Xml)
	c.Assert(err, check.IsNil)
	c.Assert(response, check.NotNil)
	requestId, err := getRequestIdFromResponse(response)
	c.Assert(requestId, check.Equals, r.ID)
	req := request{}
	err = req.getById(requestId)
	c.Assert(err, check.IsNil)
	c.Assert(req, check.NotNil)
	email, err := getUserIdentity(response)
	c.Assert(err, check.IsNil)
	c.Assert(email, check.Equals, "nuvem-teste@usp.br")
}

func (s *S) TestSamlAuthLoginValidRequestIdUserNotAuthed(c *check.C) {
	scheme := SAMLAuthScheme{}
	info, err := scheme.Info()
	params := make(map[string]string)
	params["request_id"] = info["request_id"].(string)
	_, err = scheme.Login(params)
	c.Assert(err, check.Equals, ErrRequestWaitingForCredentials)
}

func (s *S) TestSamlCallbackWithEmptyResponse(c *check.C) {
	params := make(map[string]string)
	params["callback"] = "true"
	scheme := SAMLAuthScheme{}
	scheme.Login(params)
	_, err := scheme.Login(params)
	c.Assert(err, check.Equals, ErrMissingFormValueError)
}

func (s *S) TestSamlCallbackWithInvalidResponse(c *check.C) {
	params := make(map[string]string)
	params["callback"] = "true"
	params["xml"] = "<? invalid xml response from idp ?>"
	scheme := SAMLAuthScheme{}
	scheme.Login(params)
	_, err := scheme.Login(params)
	c.Assert(err, check.Equals, ErrParseResponseError)
}

func (s *S) TestNewTokenReturnsErrorWhenUserIsNil(c *check.C) {
	t, err := newUserToken(nil)
	c.Assert(t, check.IsNil)
	c.Assert(err, check.NotNil)
	c.Assert(err, check.ErrorMatches, "^User is nil$")
}

func (s *S) TestSamlAuthName(c *check.C) {
	scheme := SAMLAuthScheme{}
	name := scheme.Name()
	c.Assert(name, check.Equals, "saml")
}

func (s *S) TestSamlAuthInfo(c *check.C) {
	scheme := SAMLAuthScheme{}
	info, err := scheme.Info()
	c.Assert(err, check.IsNil)
	c.Assert(info["request_id"], check.NotNil)
	c.Assert(info["saml_request"], check.NotNil)
	c.Assert(info["url"], check.NotNil)
	c.Assert(info["request_timeout"], check.Equals, "60")
}

func (s *S) TestSamlAuth(c *check.C) {
	user := auth.User{Email: "x@x.com"}
	token, _ := createToken(&user)
	scheme := SAMLAuthScheme{}
	strtoken, err := scheme.Auth("bearer " + token.GetValue())
	c.Assert(err, check.IsNil)
	c.Assert(token.GetValue(), check.Equals, strtoken.GetValue())
}

func (s *S) TestSamlParseXml(c *check.C) {
	xml := base64.StdEncoding.EncodeToString([]byte(readRespFromFile()))
	scheme := SAMLAuthScheme{}
	response, err := scheme.Parse(xml)
	c.Assert(err, check.IsNil)
	c.Assert(response, check.NotNil)
}

func (s *S) TestSamlAppLogin(c *check.C) {
	scheme := SAMLAuthScheme{}
	token, err := scheme.AppLogin("myApp")
	c.Assert(err, check.IsNil)
	c.Assert(token.IsAppToken(), check.Equals, true)
	c.Assert(token.GetAppName(), check.Equals, "myApp")
}

func (s *S) TestSamlAuthWithAppToken(c *check.C) {
	scheme := SAMLAuthScheme{}
	appToken, err := scheme.AppLogin("myApp")
	c.Assert(err, check.IsNil)
	token, err := scheme.Auth("bearer " + appToken.GetValue())
	c.Assert(err, check.IsNil)
	c.Assert(len(s.reqs), check.Equals, 0)
	c.Assert(token.IsAppToken(), check.Equals, true)
	c.Assert(token.GetAppName(), check.Equals, "myApp")
	c.Assert(token.GetValue(), check.Equals, appToken.GetValue())
}

func (s *S) TestSamlCreate(c *check.C) {
	scheme := SAMLAuthScheme{}
	user := auth.User{Email: "x@x.com"}
	_, err := scheme.Create(&user)
	c.Assert(err, check.IsNil)
	dbUser, err := auth.GetUserByEmail(user.Email)
	c.Assert(err, check.IsNil)
	c.Assert(dbUser.Email, check.Equals, user.Email)
	c.Assert(dbUser.Password, check.Equals, "")
}
