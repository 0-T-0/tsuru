// Copyright 2012 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package app

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/globocom/tsuru/log"
	"io"
	"os/exec"
	"strconv"
	"strings"
	"time"
)

type Unit struct {
	Type              string
	Name              string
	Machine           int
	Ip                string
	AgentState        string `yaml:"agent-state"`
	MachineAgentState string
	InstanceState     string
	InstanceId        string
	app               *App
}

func (u *Unit) destroy() ([]byte, error) {
	if u.Machine < 1 {
		return nil, errors.New("No machine associated.")
	}
	cmd := exec.Command("juju", "destroy-service", u.app.Name)
	log.Printf("destroying %s with name %s", u.Type, u.Name)
	out, err := cmd.CombinedOutput()
	log.Printf(string(out))
	if err != nil {
		return out, err
	}
	cmd = exec.Command("juju", "terminate-machine", strconv.Itoa(u.Machine))
	return cmd.CombinedOutput()
}

func (u *Unit) executeHook(hook string, w io.Writer) error {
	cmd := fmt.Sprintf("/var/lib/tsuru/hooks/%s", hook)
	return u.Command(w, w, cmd)
}

func (u *Unit) Command(stdout, stderr io.Writer, cmds ...string) error {
	if state := u.State(); state != "started" {
		return fmt.Errorf("Unit must be started to run commands, but it is %s.", state)
	}
	c := exec.Command("juju", "ssh", "-o", "StrictHostKeyChecking no", "-q", strconv.Itoa(u.Machine))
	c.Args = append(c.Args, cmds...)
	log.Printf("executing %s on %s", strings.Join(cmds, " "), u.app.Name)
	c.Stdout = stdout
	c.Stderr = stderr
	return c.Run()
}

// writeEnvVars takes all environments variables from the unit's app and writes
// them to the apprc file in the unit machine.
func (u *Unit) writeEnvVars() error {
	var buf bytes.Buffer
	cmd := "cat > /home/application/apprc <<END\n"
	cmd += fmt.Sprintf("# generated by tsuru at %s\n", time.Now().Format(time.RFC822Z))
	for k, v := range u.app.Env {
		cmd += fmt.Sprintf(`export %s="%s"`+"\n", k, v.Value)
	}
	cmd += "END\n"
	err := u.Command(&buf, &buf, cmd)
	if err != nil {
		output := buf.Bytes()
		if output == nil {
			err = fmt.Errorf("Failed to write env vars: %s.", err)
		} else {
			err = fmt.Errorf("Failed to write env vars (%s): %s.", err, output)
		}
	}
	return err
}

func (u *Unit) GetName() string {
	return u.app.Name
}

func (u *Unit) GetIp() string {
	return u.Ip
}

func (u *Unit) State() string {
	if u.InstanceState == "error" || u.AgentState == "install-error" || u.MachineAgentState == "start-error" {
		return "error"
	}
	if u.MachineAgentState == "pending" || u.MachineAgentState == "not-started" || u.MachineAgentState == "" {
		return "creating"
	}
	if u.InstanceState == "pending" || u.InstanceState == "" {
		return "creating"
	}
	if u.AgentState == "down" {
		return "down"
	}
	if u.MachineAgentState == "running" && u.AgentState == "not-started" {
		return "creating"
	}
	if u.MachineAgentState == "running" && u.InstanceState == "running" && u.AgentState == "pending" {
		return "installing"
	}
	if u.MachineAgentState == "running" && u.AgentState == "started" && u.InstanceState == "running" {
		return "started"
	}
	return "pending"
}
