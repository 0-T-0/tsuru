// Copyright 2012 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package app

import (
	"bytes"
	"fmt"
	"github.com/globocom/tsuru/log"
	"github.com/globocom/tsuru/provision"
	"io"
	"os/exec"
	"strconv"
	"strings"
	"time"
)

type Unit struct {
	Name    string
	Type    string
	Machine int
	Ip      string
	State   string
	app     *App
}

func (u *Unit) executeHook(hook string, w io.Writer) error {
	cmd := fmt.Sprintf("/var/lib/tsuru/hooks/%s", hook)
	return u.Command(w, w, cmd)
}

func (u *Unit) Command(stdout, stderr io.Writer, cmds ...string) error {
	if u.State != provision.StatusStarted {
		return fmt.Errorf("Unit must be started to run commands, but it is %q.", u.State)
	}
	c := exec.Command("juju", "ssh", "-o", "StrictHostKeyChecking no", "-q", strconv.Itoa(u.Machine))
	c.Args = append(c.Args, cmds...)
	log.Printf("executing %s on %s", strings.Join(cmds, " "), u.app.Name)
	c.Stdout = stdout
	c.Stderr = stderr
	return c.Run()
}

// writeEnvVars takes all environments variables from the unit's app and writes
// them to the apprc file in the unit machine.
func (u *Unit) writeEnvVars() error {
	var buf bytes.Buffer
	cmd := "cat > /home/application/apprc <<END\n"
	cmd += fmt.Sprintf("# generated by tsuru at %s\n", time.Now().Format(time.RFC822Z))
	for k, v := range u.app.Env {
		cmd += fmt.Sprintf(`export %s="%s"`+"\n", k, v.Value)
	}
	cmd += "END\n"
	err := u.Command(&buf, &buf, cmd)
	if err != nil {
		output := buf.Bytes()
		if output == nil {
			err = fmt.Errorf("Failed to write env vars: %s.", err)
		} else {
			err = fmt.Errorf("Failed to write env vars (%s): %s.", err, output)
		}
	}
	return err
}

func (u *Unit) GetName() string {
	return u.Name
}

func (u *Unit) GetMachine() int {
	return u.Machine
}

func (u *Unit) GetIp() string {
	return u.Ip
}
